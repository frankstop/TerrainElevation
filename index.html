<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Terrain Elevation Map with Particles (Debug)</title>
  <style>
    body { margin: 0; overflow: hidden; }
    /* Legend for the color scale */
    #legend {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 20px;
      height: 200px;
      background: linear-gradient(to top, blue, red);
      border: 1px solid #000;
    }
    #legendLabels {
      position: absolute;
      top: 10px;
      right: 40px;
      height: 200px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      color: #fff;
      font-family: sans-serif;
      font-size: 14px;
      text-shadow: 1px 1px 2px #000;
    }
  </style>
</head>
<body>
  <!-- Color scale legend -->
  <div id="legend"></div>
  <div id="legendLabels">
    <div id="minLabel">Low</div>
    <div id="maxLabel">High</div>
  </div>

  <!-- Import Three.js, OrbitControls, and Cannon‑ES via CDN -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';
    import * as CANNON from 'https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js';

    /***********************
     * PARAMETERS & CONFIG *
     ***********************/
    const params = {
      particleCount: 1000,
      particleSize: 0.2,
      terrainWidth: 20,
      terrainDepth: 20,
      heightScale: 5,
      physicsTimeStep: 1 / 60,
      // Set gravity to zero for debugging so particles don't fall.
      gravity: 0,
      boxSize: 25
    };

    /********************
     * THREE.JS SETUP   *
     ********************/
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    // Adjust camera to get a better view.
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    // Place the camera further back and slightly higher.
    camera.position.set(0, 40, 50);
    camera.lookAt(new THREE.Vector3(0, 0, 0));

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);

    // Add some basic lights.
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);

    // Add an axes helper so you can see coordinate directions.
    const axesHelper = new THREE.AxesHelper(30);
    scene.add(axesHelper);

    // Create a wireframe box to show the boundaries.
    const boxGeometry = new THREE.BoxGeometry(params.boxSize * 2, params.boxSize * 2, params.boxSize * 2);
    const boxEdges = new THREE.EdgesGeometry(boxGeometry);
    const boxMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
    const boxWireframe = new THREE.LineSegments(boxEdges, boxMaterial);
    scene.add(boxWireframe);

    /***********************
     * CANNON‑ES PHYSICS   *
     ***********************/
    const world = new CANNON.World();
    world.gravity.set(0, params.gravity, 0);
    world.broadphase = new CANNON.NaiveBroadphase();
    world.solver.iterations = 10;

    // Helper to create static walls.
    function createWall(eulerX, eulerY, eulerZ, posX, posY, posZ) {
      const shape = new CANNON.Plane();
      const body = new CANNON.Body({ mass: 0 });
      body.addShape(shape);
      body.quaternion.setFromEuler(eulerX, eulerY, eulerZ);
      body.position.set(posX, posY, posZ);
      world.addBody(body);
    }
    const bSize = params.boxSize;
    createWall(-Math.PI / 2, 0, 0, 0, -bSize, 0);    // Floor
    createWall(Math.PI / 2, 0, 0, 0, bSize, 0);       // Ceiling
    createWall(0, Math.PI / 2, 0, -bSize, 0, 0);       // Left wall
    createWall(0, -Math.PI / 2, 0, bSize, 0, 0);       // Right wall
    createWall(0, Math.PI, 0, 0, 0, -bSize);           // Back wall
    createWall(0, 0, 0, 0, 0, bSize);                  // Front wall

    /******************************
     * CREATE THE TERRAIN PARTICLES *
     ******************************/
    const particles = [];
    const particleMeshes = [];

    // Determine grid dimensions.
    const gridX = Math.ceil(Math.sqrt(params.particleCount * (params.terrainWidth / params.terrainDepth)));
    const gridZ = Math.ceil(params.particleCount / gridX);
    const dx = params.terrainWidth / gridX;
    const dz = params.terrainDepth / gridZ;
    const offsetX = -params.terrainWidth / 2;
    const offsetZ = -params.terrainDepth / 2;

    // A simple terrain function.
    function terrainHeight(x, z) {
      return Math.sin(x * 0.5) * Math.cos(z * 0.5) * params.heightScale;
    }

    // Find min and max heights.
    let minHeight = Infinity, maxHeight = -Infinity;
    for (let i = 0; i < gridX; i++) {
      for (let j = 0; j < gridZ; j++) {
        const x = offsetX + i * dx;
        const z = offsetZ + j * dz;
        const h = terrainHeight(x, z);
        minHeight = Math.min(minHeight, h);
        maxHeight = Math.max(maxHeight, h);
      }
    }

    // Map height to a color (blue to red).
    function heightToColor(h) {
      const t = (h - minHeight) / (maxHeight - minHeight);
      const r = t * 255;
      const b = (1 - t) * 255;
      return new THREE.Color(r / 255, 0, b / 255);
    }

    // Create particles.
    let particleIndex = 0;
    for (let i = 0; i < gridX; i++) {
      for (let j = 0; j < gridZ; j++) {
        if (particleIndex >= params.particleCount) break;
        const x = offsetX + i * dx + (Math.random() - 0.5) * dx * 0.5;
        const z = offsetZ + j * dz + (Math.random() - 0.5) * dz * 0.5;
        const y = terrainHeight(x, z);

        // Create Three.js mesh.
        const geometry = new THREE.SphereGeometry(params.particleSize, 8, 8);
        const material = new THREE.MeshPhongMaterial({ color: heightToColor(y) });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(x, y, z);
        scene.add(mesh);
        particleMeshes.push(mesh);

        // Create Cannon‑ES body.
        const shape = new CANNON.Sphere(params.particleSize);
        const body = new CANNON.Body({ mass: 1 });
        body.addShape(shape);
        body.position.set(x, y, z);
        world.addBody(body);
        particles.push(body);

        particleIndex++;
      }
      if (particleIndex >= params.particleCount) break;
    }

    /********************
     * ANIMATION LOOP   *
     ********************/
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      // Step physics simulation.
      world.step(params.physicsTimeStep, delta);

      // Update meshes from physics bodies.
      for (let i = 0; i < particles.length; i++) {
        particleMeshes[i].position.copy(particles[i].position);
        particleMeshes[i].quaternion.copy(particles[i].quaternion);
      }

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
